name: 🔄 Dependency Updates

on:
  schedule:
    - cron: '0 8 * * 1'  # Weekly on Monday at 8 AM UTC
  workflow_dispatch:
    inputs:
      update_type:
        description: 'Type of update to perform'
        required: true
        default: 'minor'
        type: choice
        options:
          - minor
          - major
          - all
      create_pr:
        description: 'Create pull request for updates'
        required: false
        default: true
        type: boolean

env:
  DOTNET_VERSION: '8.0.x'
  DOTNET_NOLOGO: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true

permissions:
  contents: write
  pull-requests: write
  checks: read

jobs:
  check-dependencies:
    name: 📊 Dependency Analysis
    runs-on: windows-latest

    outputs:
      has-updates: ${{ steps.check-updates.outputs.has-updates }}
      update-summary: ${{ steps.check-updates.outputs.summary }}
      security-updates: ${{ steps.security-check.outputs.has-security-updates }}

    steps:
    - name: 📥 Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: 🔧 Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: 📦 Restore dependencies
      run: dotnet restore

    - name: 🔧 Install dependency tools
      run: |
        Write-Host "Installing dotnet tools..."

        # Install tools with retry logic
        try {
          dotnet tool install --global dotnet-outdated-tool --version 4.6.4
          Write-Host "✅ dotnet-outdated-tool installed successfully"
        } catch {
          Write-Host "::warning::Failed to install dotnet-outdated-tool: $($_.Exception.Message)"
        }

        try {
          dotnet tool install --global dotnet-audit
          Write-Host "✅ dotnet-audit installed successfully"
        } catch {
          Write-Host "::warning::Failed to install dotnet-audit: $($_.Exception.Message)"
        }

        # Verify installations
        dotnet tool list --global

    - name: 🔍 Check for outdated packages
      id: check-updates
      run: |
        Write-Host "::group::Dependency Update Check"

        try {
          # Check for outdated packages with better error handling
          Write-Host "Running dotnet outdated check..."

          # First try with JSON output
          $outdatedOutput = & dotnet outdated --output json 2>&1
          $exitCode = $LASTEXITCODE

          Write-Host "Exit code: $exitCode"
          Write-Host "Raw output: $outdatedOutput"

          if ($exitCode -eq 0 -and $outdatedOutput -and $outdatedOutput.ToString().Trim().StartsWith('{')) {
            Write-Host "Parsing JSON output..."
            $outdated = $outdatedOutput | ConvertFrom-Json

            $totalUpdates = 0
            $majorUpdates = 0
            $minorUpdates = 0
            $patchUpdates = 0
            $updateSummary = @()

            if ($outdated.Projects) {
              foreach ($project in $outdated.Projects) {
                if ($project.TargetFrameworks) {
                  foreach ($framework in $project.TargetFrameworks) {
                    if ($framework.Dependencies) {
                      foreach ($dependency in $framework.Dependencies) {
                        $totalUpdates++

                        # Try to parse versions safely
                        try {
                          $current = [Version]$dependency.ResolvedVersion
                          $latest = [Version]$dependency.LatestVersion

                          if ($latest.Major -gt $current.Major) {
                            $majorUpdates++
                            $updateType = "major"
                          } elseif ($latest.Minor -gt $current.Minor) {
                            $minorUpdates++
                            $updateType = "minor"
                          } else {
                            $patchUpdates++
                            $updateType = "patch"
                          }

                          $updateSummary += "$($dependency.Name): $($dependency.ResolvedVersion) → $($dependency.LatestVersion) ($updateType)"
                        } catch {
                          Write-Host "::warning::Could not parse version for $($dependency.Name)"
                          $updateSummary += "$($dependency.Name): version parsing failed"
                        }
                      }
                    }
                  }
                }
              }
            }

            Write-Host "📊 Update Summary:"
            Write-Host "  Total packages to update: $totalUpdates"
            Write-Host "  Major updates: $majorUpdates"
            Write-Host "  Minor updates: $minorUpdates"
            Write-Host "  Patch updates: $patchUpdates"

            if ($totalUpdates -gt 0) {
              echo "has-updates=true" >> $env:GITHUB_OUTPUT
              $summaryText = "Total: $totalUpdates (Major: $majorUpdates, Minor: $minorUpdates, Patch: $patchUpdates)"
              echo "summary=$summaryText" >> $env:GITHUB_OUTPUT

              # Export detailed updates for later use
              $updateSummary | ConvertTo-Json | Out-File -FilePath "update-summary.json"
            } else {
              echo "has-updates=false" >> $env:GITHUB_OUTPUT
              echo "summary=No updates available" >> $env:GITHUB_OUTPUT
            }
          } else {
            # Fallback: Try simple text output
            Write-Host "JSON parsing failed, trying simple check..."
            $simpleOutput = & dotnet outdated 2>&1

            if ($simpleOutput -match "No outdated packages found") {
              Write-Host "✅ No outdated packages found"
              echo "has-updates=false" >> $env:GITHUB_OUTPUT
              echo "summary=No updates available" >> $env:GITHUB_OUTPUT
            } elseif ($simpleOutput -match "The following sources were used") {
              Write-Host "⚠️ Outdated packages detected (simple check)"
              echo "has-updates=true" >> $env:GITHUB_OUTPUT
              echo "summary=Updates available (detailed analysis failed)" >> $env:GITHUB_OUTPUT
            } else {
              Write-Host "::warning::Could not determine update status"
              echo "has-updates=false" >> $env:GITHUB_OUTPUT
              echo "summary=Check inconclusive" >> $env:GITHUB_OUTPUT
            }
          }
        } catch {
          Write-Host "::error::Exception during dependency check: $($_.Exception.Message)"
          echo "has-updates=false" >> $env:GITHUB_OUTPUT
          echo "summary=Check failed with exception" >> $env:GITHUB_OUTPUT
        }

        Write-Host "::endgroup::"

    - name: 🛡️ Security vulnerability check
      id: security-check
      run: |
        Write-Host "::group::Security Vulnerability Check"

        # Check for vulnerable packages
        $vulnerableOutput = dotnet list package --vulnerable --include-transitive 2>&1

        if ($vulnerableOutput -match "has the following vulnerable packages") {
          Write-Host "::warning::Security vulnerabilities found!"
          Write-Host "has-security-updates=true" >> $env:GITHUB_OUTPUT

          # Extract vulnerability details
          $vulnerableOutput | Out-File -FilePath "vulnerabilities.txt"
        } else {
          Write-Host "::notice::✅ No security vulnerabilities found"
          Write-Host "has-security-updates=false" >> $env:GITHUB_OUTPUT
        }

        Write-Host "::endgroup::"

    - name: 📤 Upload analysis results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: dependency-analysis
        path: |
          update-summary.json
          vulnerabilities.txt
        retention-days: 30

  update-dependencies:
    name: 🔄 Update Dependencies
    runs-on: windows-latest
    needs: check-dependencies
    if: needs.check-dependencies.outputs.has-updates == 'true' || needs.check-dependencies.outputs.security-updates == 'true'

    steps:
    - name: 📥 Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: 🔧 Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: 📦 Restore dependencies
      run: dotnet restore

    - name: 🔧 Install update tools
      run: |
        dotnet tool install --global dotnet-outdated-tool

    - name: 🔄 Perform dependency updates
      id: update-deps
      run: |
        Write-Host "::group::Dependency Updates"

        $updateType = "${{ github.event.inputs.update_type || 'minor' }}"
        $hasSecurityUpdates = "${{ needs.check-dependencies.outputs.security-updates }}" -eq "true"

        Write-Host "Update type: $updateType"
        Write-Host "Security updates needed: $hasSecurityUpdates"

        # Always update security vulnerabilities regardless of update type
        if ($hasSecurityUpdates) {
          Write-Host "🛡️ Prioritizing security updates..."

          # Get vulnerable packages and update them
          $vulnerablePackages = dotnet list package --vulnerable --include-transitive |
            Select-String ">\s+(\S+)\s+" |
            ForEach-Object { $_.Matches.Groups[1].Value } |
            Sort-Object |
            Get-Unique

          foreach ($package in $vulnerablePackages) {
            Write-Host "Updating vulnerable package: $package"
            try {
              dotnet add package $package
            } catch {
              Write-Host "::warning::Failed to update $package : $_"
            }
          }
        }

        # Update other packages based on update type
        switch ($updateType) {
          "all" {
            Write-Host "🔄 Updating all packages to latest versions..."
            dotnet outdated --upgrade
          }
          "major" {
            Write-Host "🔄 Updating packages including major versions..."
            dotnet outdated --upgrade --version-lock Major
          }
          "minor" {
            Write-Host "🔄 Updating packages with minor and patch versions..."
            dotnet outdated --upgrade --version-lock Minor
          }
        }

        Write-Host "::endgroup::"

    - name: 🏗️ Build and test after updates
      run: |
        Write-Host "::group::Build Verification"

        # Restore with updated packages
        dotnet restore --force

        # Build to check for breaking changes
        $buildResult = dotnet build --configuration Release --no-restore 2>&1

        if ($LASTEXITCODE -ne 0) {
          Write-Host "::error::Build failed after dependency updates!"
          Write-Host $buildResult
          exit 1
        }

        Write-Host "✅ Build successful after dependency updates"
        Write-Host "::endgroup::"

    - name: 🧪 Run tests after updates
      run: |
        Write-Host "::group::Test Verification"

        $testResult = dotnet test --configuration Release --no-build --verbosity normal 2>&1

        if ($LASTEXITCODE -ne 0) {
          Write-Host "::error::Tests failed after dependency updates!"
          Write-Host $testResult
          exit 1
        }

        Write-Host "✅ All tests passed after dependency updates"
        Write-Host "::endgroup::"

    - name: 📝 Generate update report
      id: generate-report
      run: |
        Write-Host "::group::Update Report Generation"

        # Check what actually changed
        $changedFiles = git diff --name-only

        if ($changedFiles) {
          Write-Host "Files changed:"
          $changedFiles | ForEach-Object { Write-Host "  $_" }

          # Generate commit message
          $commitMessage = "chore(deps): update dependencies"

          if ("${{ needs.check-dependencies.outputs.security-updates }}" -eq "true") {
            $commitMessage += " (includes security updates)"
          }

          # Create detailed commit body
          $commitBody = "Automated dependency update`n`n" +
                       "Update type: ${{ github.event.inputs.update_type || 'minor' }}`n" +
                       "Summary: ${{ needs.check-dependencies.outputs.update-summary }}`n`n" +
                       "Security updates included: ${{ needs.check-dependencies.outputs.security-updates }}`n`n" +
                       "✅ Build and tests verified after updates"

          Write-Host "commit-message=$commitMessage" >> $env:GITHUB_OUTPUT
          Write-Host "commit-body<<EOF" >> $env:GITHUB_OUTPUT
          Write-Host $commitBody >> $env:GITHUB_OUTPUT
          Write-Host "EOF" >> $env:GITHUB_OUTPUT
          Write-Host "has-changes=true" >> $env:GITHUB_OUTPUT
        } else {
          Write-Host "No changes detected"
          Write-Host "has-changes=false" >> $env:GITHUB_OUTPUT
        }

        Write-Host "::endgroup::"

    - name: 📤 Create Pull Request
      if: steps.generate-report.outputs.has-changes == 'true' && (github.event.inputs.create_pr != 'false')
      uses: peter-evans/create-pull-request@v6
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        branch: automated-dependency-updates
        title: ${{ steps.generate-report.outputs.commit-message }}
        body: |
          ${{ steps.generate-report.outputs.commit-body }}

          ## 🔍 Changes Made

          This PR contains automated dependency updates that have been:
          - ✅ Built successfully
          - ✅ Tested and verified
          - 🛡️ Checked for security vulnerabilities

          ## 📊 Update Summary

          ${{ needs.check-dependencies.outputs.update-summary }}

          ## 🚦 Next Steps

          1. Review the changes in this PR
          2. Check for any breaking changes in the updated packages
          3. Verify that all functionality still works as expected
          4. Merge if everything looks good

          ---
          🤖 This PR was created automatically by the dependency update workflow
        labels: |
          dependencies
          automated-pr
          ${{ needs.check-dependencies.outputs.security-updates == 'true' && 'security' || '' }}
        reviewers: |
          gOOvER
        draft: false
        delete-branch: true

    - name: 📝 Direct commit (if no PR requested)
      if: steps.generate-report.outputs.has-changes == 'true' && github.event.inputs.create_pr == 'false'
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add -A
        git commit -m "${{ steps.generate-report.outputs.commit-message }}"
        git push

  # Notify on completion
  notify-completion:
    name: 📢 Notify Completion
    runs-on: windows-latest
    needs: [check-dependencies, update-dependencies]
    if: always()

    steps:
    - name: 📊 Summary report
      run: |
        Write-Host "::group::📊 Dependency Update Summary"
        Write-Host "## Dependency Update Results"
        Write-Host ""

        $check_result = "${{ needs.check-dependencies.result }}"
        $update_result = "${{ needs.update-dependencies.result }}"
        $has_updates = "${{ needs.check-dependencies.outputs.has-updates }}"
        $update_summary = "${{ needs.check-dependencies.outputs.update-summary }}"
        $security_updates = "${{ needs.check-dependencies.outputs.security-updates }}"

        Write-Host "| Stage | Result |"
        Write-Host "|-------|--------|"
        Write-Host "| Dependency Check | $check_result |"
        Write-Host "| Updates Applied | $update_result |"
        Write-Host ""

        if ($has_updates -eq "true") {
          Write-Host "📦 **Updates Available**: $update_summary"
        } else {
          Write-Host "✅ **No updates needed** - all dependencies are current"
        }

        if ($security_updates -eq "true") {
          Write-Host "🛡️ **Security updates were processed**"
        }

        if ($update_result -eq "success") {
          Write-Host "🎉 **Dependency update completed successfully!**"
        } elseif ($update_result -eq "failure") {
          Write-Host "❌ **Dependency update failed** - please check the logs"
        } elseif ($has_updates -eq "false") {
          Write-Host "ℹ️ **No action needed** - dependencies are up to date"
        }

        Write-Host "::endgroup::"
