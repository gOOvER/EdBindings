name: üìä Code Quality Analysis (BACKUP - DISABLED)

# This workflow is disabled - it's a backup of the old complex workflow
# The new simplified workflow is in code-quality.yml
on:
  workflow_dispatch:
    inputs:
      force_run:
        description: 'Force run of backup workflow (for testing only)'
        required: false
        type: boolean
        default: false
  pull_request:
    branches: [ main, develop ]
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  DOTNET_VERSION: '8.0.x'
  DOTNET_NOLOGO: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true

permissions:
  contents: read
  pull-requests: write
  checks: write

jobs:
  # Simplified code quality check
  code-quality:
    name: ÔøΩ Code Quality Check
    runs-on: ubuntu-latest
    
    steps:
    - name: üì• Checkout repository
      uses: actions/checkout@v4

    - name: üîß Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: üì¶ Restore dependencies
      run: dotnet restore

    - name: üèóÔ∏è Build project
      run: dotnet build --no-restore --configuration Release

    - name: üèóÔ∏è Build solution for analysis
      run: |
        dotnet build --configuration Release --no-restore --verbosity normal /p:TreatWarningsAsErrors=true /p:WarningsAsErrors= /p:WarningsNotAsErrors=CS1591

    - name: üìä Calculate code metrics
      run: |
        Write-Host "::group::Code Metrics Calculation"
        
        # Count lines of code
        $sourceFiles = Get-ChildItem -Path "src" -Recurse -Include "*.cs" -Exclude "*AssemblyInfo.cs", "*GlobalAssemblyInfo.cs", "*.Designer.cs", "*.g.cs"
        $totalLines = 0
        $totalCodeLines = 0
        $totalFiles = $sourceFiles.Count
        
        foreach ($file in $sourceFiles) {
          $content = Get-Content $file.FullName
          $totalLines += $content.Count
          
          # Count non-empty, non-comment lines
          $codeLines = $content | Where-Object { 
            $_.Trim() -ne "" -and 
            -not $_.Trim().StartsWith("//") -and 
            -not $_.Trim().StartsWith("/*") -and 
            -not $_.Trim().StartsWith("*") -and
            -not $_.Trim().StartsWith("using ")
          }
          $totalCodeLines += $codeLines.Count
        }
        
        Write-Host "üìÅ Total source files: $totalFiles"
        Write-Host "üìè Total lines: $totalLines"
        Write-Host "üíª Code lines: $totalCodeLines"
        Write-Host "üìä Code density: $([math]::Round(($totalCodeLines / $totalLines) * 100, 1))%"
        
        # Calculate complexity indicators
        $classCount = (Select-String -Path $sourceFiles -Pattern "^\s*(public|internal|private)?\s*(static)?\s*class\s+" | Measure-Object).Count
        $methodCount = (Select-String -Path $sourceFiles -Pattern "^\s*(public|internal|private|protected)?\s*(static)?\s*\w+\s+\w+\s*\(" | Measure-Object).Count
        
        Write-Host "üèóÔ∏è Classes: $classCount"
        Write-Host "‚öôÔ∏è Methods: $methodCount"
        Write-Host "üìê Avg methods per class: $([math]::Round($methodCount / $classCount, 1))"
        
        # Export metrics for reporting
        $metrics = @{
          TotalFiles = $totalFiles
          TotalLines = $totalLines
          CodeLines = $totalCodeLines
          CodeDensity = [math]::Round(($totalCodeLines / $totalLines) * 100, 1)
          Classes = $classCount
          Methods = $methodCount
          AvgMethodsPerClass = [math]::Round($methodCount / $classCount, 1)
        }
        
        $metrics | ConvertTo-Json | Out-File -FilePath "code-metrics.json"
        
        Write-Host "::endgroup::"

    - name: üîç Code complexity analysis
      run: |
        Write-Host "::group::Complexity Analysis"
        
        # Analyze method complexity patterns (simplified)
        $sourceFiles = Get-ChildItem -Path "src" -Recurse -Include "*.cs"
        
        # Check for large files
        $largeFiles = $sourceFiles | Where-Object { 
          (Get-Content $_.FullName).Count -gt 500 
        }
        
        if ($largeFiles.Count -gt 0) {
          Write-Host "::warning::Found $($largeFiles.Count) large files (>500 lines). Consider splitting."
          foreach ($file in $largeFiles) {
            $lineCount = (Get-Content $file.FullName).Count
            Write-Host "  - $($file.Name): $lineCount lines"
          }
        }
        
        # Check for deep nesting (simplified)
        $deepNesting = $sourceFiles | ForEach-Object {
          Select-String -Path $_.FullName -Pattern "^\s{16,}" -AllMatches
        }
        
        if ($deepNesting.Count -gt 0) {
          Write-Host "::warning::Deep nesting detected in $($deepNesting.Count) locations. Consider refactoring."
        }
        
        Write-Host "::endgroup::"

    - name: üìã Maintainability analysis
      run: |
        Write-Host "::group::Maintainability Analysis"
        
        # Check for code smells
        $codeSmells = @()
        
        # Code smells analysis
        $sourceFiles = Get-ChildItem -Path "src" -Recurse -Include "*.cs"
        
        # Check for large files
        $largeFiles = $sourceFiles | Where-Object { 
          (Get-Content $_.FullName).Count -gt 300 
        }
        
        foreach ($file in $largeFiles) {
          $lineCount = (Get-Content $file.FullName).Count
          Write-Host "::notice::Large file: $($file.Name) ($lineCount lines)"
          $codeSmells += "Large file: $($file.Name)"
        }
        
        # Check for TODO/FIXME comments
        $todos = $sourceFiles | ForEach-Object { 
          Select-String -Path $_.FullName -Pattern "(TODO|FIXME|HACK)" -AllMatches 
        }
        
        if ($todos.Count -gt 0) {
          Write-Host "::notice::Found $($todos.Count) TODO/FIXME comments"
          $codeSmells += "Unfinished work: $($todos.Count) comments"
        }
        
        # Export maintainability report
        $maintainability = @{
          LargeFiles = $largeFiles.Count
          TodoComments = $todos.Count
          CodeSmells = $codeSmells.Count
        }
        
        $maintainability | ConvertTo-Json | Out-File -FilePath "maintainability-report.json"
        
        Write-Host "::endgroup::"

    - name: üì§ Upload metrics reports
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: code-metrics
        path: |
          code-metrics.json
          maintainability-report.json
        retention-days: 30

  # Static code analysis with multiple tools
  static-analysis:
    name: üî¨ Static Code Analysis
    runs-on: windows-latest
    
    steps:
    - name: üì• Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: üîß Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: üì¶ Restore dependencies
      run: dotnet restore

    - name: üîß Install analysis tools
      run: |
        # Install StyleCop analyzers for main project
        dotnet add src/EdBindings/EdBindings.csproj package StyleCop.Analyzers --version 1.2.0-beta.556
        
        # Install StyleCop analyzers for model project  
        dotnet add src/EdBindings.Model.BindingsRaw/EdBindings.Model.csproj package StyleCop.Analyzers --version 1.2.0-beta.556
        
        # Install Microsoft Code Analysis for main project
        dotnet add src/EdBindings/EdBindings.csproj package Microsoft.CodeAnalysis.NetAnalyzers --version 8.0.0
        
        # Install Microsoft Code Analysis for model project
        dotnet add src/EdBindings.Model.BindingsRaw/EdBindings.Model.csproj package Microsoft.CodeAnalysis.NetAnalyzers --version 8.0.0

    - name: üèóÔ∏è Build with enhanced analysis
      run: |
        Write-Host "::group::Static Analysis Build"
        dotnet build --configuration Release --no-restore --verbosity normal /p:TreatWarningsAsErrors=false /p:WarningsAsErrors= /p:RunAnalyzersDuringBuild=true /p:RunCodeAnalysis=true /p:CodeAnalysisRuleSet=analyzers.ruleset
        Write-Host "::endgroup::"

    - name: üìä Generate code analysis report
      run: |
        Write-Host "::group::Code Analysis Report"
        
        # Run additional analysis
        dotnet format --verify-no-changes --report format-report.json --include src/
        
        # Analyze XAML files
        $xamlFiles = Get-ChildItem -Recurse -Include "*.xaml"
        Write-Host "üì± XAML files found: $($xamlFiles.Count)"
        
        foreach ($xaml in $xamlFiles) {
          $content = Get-Content $xaml.FullName -Raw
          
          # Check for performance issues in XAML
          if ($content -match 'x:Name=".*".*x:Name=".*"') {
            Write-Host "::warning::Multiple x:Name attributes in $($xaml.Name)"
          }
          
          if ($content -match 'Binding.*UpdateSourceTrigger=PropertyChanged') {
            Write-Host "::notice::Frequent binding updates in $($xaml.Name) - consider performance impact"
          }
        }
        
        Write-Host "::endgroup::"

    - name: üß™ Code coverage quality gate
      run: |
        Write-Host "::group::Coverage Quality Gate"
        
        # Run tests with coverage
        dotnet test --configuration Release --no-build --verbosity normal `
          --collect:"XPlat Code Coverage" `
          --results-directory ./coverage `
          -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=opencover
        
        # Generate coverage report
        reportgenerator `
          -reports:"coverage/**/coverage.opencover.xml" `
          -targetdir:"coverage/report" `
          -reporttypes:"JsonSummary;Badges" `
          -title:"EdBindings Coverage Report"
        
        # Parse coverage data
        if (Test-Path "coverage/report/Summary.json") {
          $coverageData = Get-Content "coverage/report/Summary.json" | ConvertFrom-Json
          $lineCoverage = [math]::Round($coverageData.summary.linecoverage, 1)
          $branchCoverage = [math]::Round($coverageData.summary.branchcoverage, 1)
          
          Write-Host "üìä Line Coverage: $lineCoverage%"
          Write-Host "üåø Branch Coverage: $branchCoverage%"
          
          # Quality gates
          if ($lineCoverage -lt 70) {
            Write-Host "::error::Line coverage ($lineCoverage%) is below minimum threshold (70%)"
            exit 1
          } elseif ($lineCoverage -lt 85) {
            Write-Host "::warning::Line coverage ($lineCoverage%) is below recommended threshold (85%)"
          } else {
            Write-Host "::notice::‚úÖ Excellent line coverage ($lineCoverage%)!"
          }
          
          if ($branchCoverage -lt 60) {
            Write-Host "::warning::Branch coverage ($branchCoverage%) is below recommended threshold (60%)"
          }
        }
        
        Write-Host "::endgroup::"

    - name: üì§ Upload analysis reports
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: static-analysis
        path: |
          coverage/report/**/*
          format-report.json
        retention-days: 30

  # Documentation quality check
  documentation-quality:
    name: üìö Documentation Quality
    runs-on: ubuntu-latest
    
    steps:
    - name: üì• Checkout repository
      uses: actions/checkout@v4

    - name: üîç Analyze documentation coverage
      run: |
        echo "::group::Documentation Analysis"
        
        # Count XML documentation
        cs_files=$(find src/ -name "*.cs" -type f | wc -l)
        documented_methods=$(grep -r "/// <summary>" src/ | wc -l)
        
        echo "üìÑ C# files: $cs_files"
        echo "üìù Documented methods: $documented_methods"
        
        if [ $cs_files -gt 0 ]; then
          doc_ratio=$(echo "scale=1; $documented_methods * 100 / $cs_files" | bc -l)
          echo "üìä Documentation ratio: ${doc_ratio}%"
          
          if [ $(echo "$doc_ratio < 50" | bc -l) -eq 1 ]; then
            echo "::warning::Low documentation coverage (${doc_ratio}%). Consider adding XML documentation."
          elif [ $(echo "$doc_ratio >= 80" | bc -l) -eq 1 ]; then
            echo "::notice::‚úÖ Excellent documentation coverage (${doc_ratio}%)!"
          fi
        fi
        
        # Check README quality
        if [ -f "README.md" ]; then
          readme_lines=$(wc -l < README.md)
          echo "üìñ README.md lines: $readme_lines"
          
          if [ $readme_lines -lt 20 ]; then
            echo "::warning::README.md is quite short. Consider adding more details."
          fi
          
          # Check for essential sections
          if ! grep -qi "installation\|setup" README.md; then
            echo "::warning::README.md missing installation/setup section"
          fi
          
          if ! grep -qi "usage\|how to" README.md; then
            echo "::warning::README.md missing usage section"
          fi
        else
          echo "::error::README.md is missing!"
        fi
        
        echo "::endgroup::"

    - name: üî§ Spell check documentation  
      uses: crate-ci/typos@master

  # Quality summary report  
  quality-summary:
    name: üìã Quality Summary Report
    runs-on: ubuntu-latest
    if: always()
    
    permissions:
      contents: read
      pull-requests: write
    
    steps:
    - name: üì• Checkout repository
      uses: actions/checkout@v4
    
    - name: üìä Generate quality report
      id: quality-report
      run: |
        echo "::group::üìä Code Quality Summary"
        
        # Simple quality checks based on project structure
        score=0
        total_checks=3
        
        # Check 1: Source code exists
        if [ -d "src" ] && [ $(find src -name "*.cs" | wc -l) -gt 0 ]; then
          echo "‚úÖ Code Metrics: Found $(find src -name "*.cs" | wc -l) C# files"
          score=$((score + 1))
          metrics_status="success"
        else
          echo "‚ùå Code Metrics: No C# source files found"
          metrics_status="failure"  
        fi
        
        # Check 2: Project builds successfully
        if [ -f "EdBindings.sln" ]; then
          echo "‚úÖ Static Analysis: Solution file present"
          score=$((score + 1))
          analysis_status="success"
        else
          echo "‚ùå Static Analysis: No solution file found"
          analysis_status="failure"
        fi
        
        # Check 3: Documentation exists  
        if [ -f "README.md" ] && [ $(wc -l < README.md) -gt 20 ]; then
          echo "‚úÖ Documentation: README with $(wc -l < README.md) lines"
          score=$((score + 1))
          docs_status="success"
        else
          echo "‚ùå Documentation: Missing or minimal README"
          docs_status="failure"
        fi
        
        echo ""
        echo "| Quality Check | Status | Details |"
        echo "|---------------|--------|---------|"
        echo "| Code Metrics | $metrics_status | Lines of code, complexity analysis |"
        echo "| Static Analysis | $analysis_status | Code style, potential issues |"
        echo "| Documentation | $docs_status | README, XML docs, spell check |"
        echo ""
        
        quality_percentage=$((score * 100 / total_checks))
        
        echo "## üéØ Overall Quality Score: $quality_percentage%"
        echo ""
        
        if [ $quality_percentage -ge 90 ]; then
          echo "üèÜ **Excellent!** Your code meets high quality standards."
          echo "quality_badge=excellent" >> $GITHUB_OUTPUT
        elif [ $quality_percentage -ge 70 ]; then
          echo "‚úÖ **Good!** Code quality is acceptable."  
          echo "quality_badge=good" >> $GITHUB_OUTPUT
        else
          echo "‚ö†Ô∏è **Needs Improvement** Code quality can be enhanced."
          echo "quality_badge=needs-improvement" >> $GITHUB_OUTPUT
        fi
        
        echo "::endgroup::"